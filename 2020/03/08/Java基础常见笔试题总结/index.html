<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Java基础常见笔试题总结 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="Java基础常见笔试题总结原文链接 1.什么是Java虚拟机？为什么Java被称作是“平台无关的编程语言”？Java虚拟机是一个可以执行Java字节码的虚拟机进程。Jjava源程序（.java）被编译器编译成字节码文件（.class）。字节码文件将由java虚拟机，解释成机器码（不同平台的机器码不同）。利用机器码操作硬件和操作系统。因为不同的平台装有不同的JVM，它们能够将相同的.class文件，">
<meta property="og:type" content="article">
<meta property="og:title" content="Java基础常见笔试题总结">
<meta property="og:url" content="http://yoursite.com/2020/03/08/Java%E5%9F%BA%E7%A1%80%E5%B8%B8%E8%A7%81%E7%AC%94%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="Java基础常见笔试题总结原文链接 1.什么是Java虚拟机？为什么Java被称作是“平台无关的编程语言”？Java虚拟机是一个可以执行Java字节码的虚拟机进程。Jjava源程序（.java）被编译器编译成字节码文件（.class）。字节码文件将由java虚拟机，解释成机器码（不同平台的机器码不同）。利用机器码操作硬件和操作系统。因为不同的平台装有不同的JVM，它们能够将相同的.class文件，">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2020-03-08T15:01:16.319Z">
<meta property="article:modified_time" content="2020-03-08T14:58:21.017Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 4.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-Java基础常见笔试题总结" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/08/Java%E5%9F%BA%E7%A1%80%E5%B8%B8%E8%A7%81%E7%AC%94%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/" class="article-date">
  <time datetime="2020-03-08T15:01:16.319Z" itemprop="datePublished">2020-03-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Java基础常见笔试题总结
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="Java基础常见笔试题总结"><a href="#Java基础常见笔试题总结" class="headerlink" title="Java基础常见笔试题总结"></a>Java基础常见笔试题总结</h2><p><a href="https://blog.csdn.net/qq_16633405/article/details/79211002" target="_blank" rel="noopener">原文链接</a></p>
<p><strong>1.什么是Java虚拟机？为什么Java被称作是“平台无关的编程语言”？</strong><br>Java虚拟机是一个可以执行Java字节码的<strong>虚拟机进程</strong>。Jjava源程序（.java）被编译器编译成字节码文件（.class）。字节码文件将由java虚拟机，解释成机器码（不同平台的机器码不同）。利用机器码操作硬件和操作系统。因为不同的平台装有不同的JVM，它们能够将相同的.class文件，解释成不同平台所需要的机器码。正是因为有JVM的存在，java被称为平台无关的编程语言</p>
<p><strong>2.“static”关键字是什么意思？Java中是否可以覆盖(override 也叫方法重写 一个private或者是static的方法？</strong><br>“static”关键字表明一个成员变量或者是成员方法<strong>可以在没有所属的类的实例变量的情况下被访问</strong>。<br>Java中static方法<strong>不能被覆盖</strong>，<strong>因为</strong>方法覆盖是基于运行时动态绑定的，而static方法是编译时静态绑定的。static方法跟类的任何实例都不相关，所以概念上不适用。</p>
<blockquote>
<p><strong>方法重写override和方法重载overload的区别</strong></p>
<p><strong>方法重写(override)</strong>：某子类对父类的允许访问的方法的实现过程进行重新编写, 返回值和形参都不能改变,但其中的方法可变。(外壳不变核心重写)<br>        编译时只是检查各实例对象对应的类的方法的参数的引用类型,在运行时，Java 虚拟机(JVM)就可以指定对象的类型并且运行该对象的方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDog</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">Animal a = <span class="keyword">new</span> Animal(); <span class="comment">// Animal 对象</span></span><br><span class="line">Animal b = <span class="keyword">new</span> Dog(); <span class="comment">// Dog 对象(注:前文有class Dog extends Animal,方法有重写的move和新添加的dark)</span></span><br><span class="line"></span><br><span class="line">a.move();<span class="comment">// 执行 Animal 类的方法</span></span><br><span class="line">b.move();<span class="comment">//执行 Dog 类的方法</span></span><br><span class="line">b.bark();     &#125;</span><br><span class="line"><span class="comment">//!该程序将抛出一个编译错误，因为b的引用类型Animal没有bark方法。!</span></span><br></pre></td></tr></table></figure>

<p><strong>方法的重写规则</strong></p>
<ul>
<li><strong>参数列表</strong>必须完全与被重写方法的<strong>相同</strong>。</li>
<li>返回类型与被重写方法的<strong>返回类型可以不相同</strong>，但是<strong>必须是父类返回值的派生类</strong>（java5 及更早版本返回类型要一样，java7 及更高版本可以不同）。</li>
<li><strong>访问权限</strong>不能比父类中被重写的方法的访问权限更低。例如：如果父类的一个方法被声明为 public，那么在子类中重写该方法就不能声明为 protected。</li>
<li>父类的<strong>成员方法</strong>只能被它的子类重写。</li>
<li>声明为 <strong>final</strong> 的方法不能被重写。</li>
<li>声明为 <strong>static</strong> 的方法不能被重写，但是能够被<strong>再次声明</strong>。</li>
<li>子类和父类在<strong>同一个包中</strong>，那么子类可以重写父类所有方法，<strong>除了</strong>声明为 private 和 final 的方法。</li>
<li>子类和父类<strong>不在同一个包</strong>中，那么子类只能够重写父类的声明为 <strong>public 和 protected 的非 final 方法</strong>。</li>
<li>重写的方法<strong>能够抛出任何非强制异常</strong>，无论被重写的方法是否抛出异常。但是，重写的方法<strong>不能抛出新的强制性异常</strong>，或者比被重写方法声明的<strong>更广泛的强制性异常</strong>，反之则可以。   (父类中被重写的方法(它爹)可以不报异常但子类中重写它的方法(它儿子)可以报任何非强制异常; 它爹可报更广泛的强制性异常,它儿子报出成都强制性异常不能超出他爹)</li>
<li><strong>构造方法不能被重写。</strong></li>
<li>如果<strong>不能继承</strong>一个方法，则<strong>不能重写</strong>这个方法。(就是必须在子类里选择父类里原有的方法进行重写,不是父子关系就拜拜)</li>
<li>需要在子类中调用父类的被重写方法时，要使用 <strong>super 关键字</strong>。</li>
</ul>
<hr>
<p><strong>方法重载(overload)</strong>：是在一个类里面，方法名字相同，而参数不同。返回类型可以相同也可以不同。<br>    每个重载的方法（或者构造函数）都必须有一个独一无二的参数类型列表。<br>    最常用的地方就是构造器的重载。</p>
<p><strong>重载规则:</strong></p>
<ul>
<li>被重载的方法<strong>必须改变参数列表(参数个数或类型不一样)</strong>；</li>
<li>被重载的方法<strong>可以改变返回类型</strong>；</li>
<li>被重载的方法可以<strong>改变访问修饰符</strong>；</li>
<li>被重载的方法可以<strong>声明新的或更广的检查异常</strong>；</li>
<li>方法能够<strong>在同一个类中</strong>或者<strong>在一个子类</strong>中被重载。</li>
<li>无法以返回值类型作为重载函数的区分标准。</li>
</ul>
<p>重写是父类与子类之间多态性的一种表现，重载可以理解成多态的具体表现形式是一个类中多态性的一种表现。。</p>
<p><strong>5.Overload和Override的区别。Overloaded的方法是否可以改变返回值的类型?</strong></p>
<table>
<thead>
<tr>
<th align="left">区别点(4点)</th>
<th align="left">重载方法</th>
<th align="left">重写方法</th>
</tr>
</thead>
<tbody><tr>
<td align="left">参数列表</td>
<td align="left">必须修改</td>
<td align="left">一定不能修改</td>
</tr>
<tr>
<td align="left">返回类型</td>
<td align="left">可以修改</td>
<td align="left">一定不能修改</td>
</tr>
<tr>
<td align="left">异常</td>
<td align="left">可以修改</td>
<td align="left">可以减少或删除，一定不能抛出新的或者更广的异常</td>
</tr>
<tr>
<td align="left">访问</td>
<td align="left">可以修改</td>
<td align="left">一定不能做更严格的限制（可以降低限制）</td>
</tr>
</tbody></table>
</blockquote>
<p><strong>3.是否可以在static环境中访问非static变量？</strong><br>static变量在Java中是属于类的，它在所有的实例中的值是一样的。<code>当类被Java虚拟机载入的时候，会对static变量进行初始化。</code>如果你的代码尝试不用实例来访问非static的变量，编译器会报错，因为这些变量还没有被创建出来，还没有跟任何实例关联上。</p>
<p><strong>4.Java支持的数据类型有哪些？什么是自动拆装箱？</strong><br>Java语言支持的8中基本数据类型是(8个)： byte\short\ int \ long \ float \ double \ boolean \ char<br>自动装箱是Java编译器在<strong>基本数据类型</strong>和<strong>对应的对象包装类型</strong>之间做的一个<strong>转化</strong>。比如：把int转化成Integer，double转化成double，等等。反之就是自动拆箱。</p>
<p><strong>6.Java支持多继承么？</strong><br>不支持，Java不支持多继承。每个类都只能继承一个类，但是可以实现多个接口。</p>
<p><strong>7.接口和抽象类的区别是什么？</strong></p>
<p>从设计层面来说，抽象是对类的抽象，是一种模板设计，接口是行为的抽象，是一种行为的规范。</p>
<p>Java提供和支持创建抽象类和接口。它们的实现有共同点，<strong>不同点在于：</strong><br>    •  接口中所有的方法隐含的都是抽象的。而抽象类则可以同时包含抽象和非抽象的方法。<br>    •  类可以实现很多个接口，但是只能继承一个抽象类<br>    •  类如果要实现一个接口，它<strong>必须要实现接口声明的所有方法</strong>。但是，类可以不实现抽象类声明的所有方法，当然，在这种情况下，<strong>类也必须得声明成是抽象的</strong>。<br>    •  抽象类可以在不提供接口方法实现的情况下实现接口。<br>    •  Java接口中声明的变量默认都是final的。抽象类可以包含非final的变量。<br>    •  Java接口中的成员函数默认是public的。抽象类的成员函数可以是private，protected或者是public。<br>    •  接口是绝对抽象的，不可以被实例化。抽象类也不可以被实例化，但是，如果它包含main方法的话是可以被调用的。<br>也可以参考JDK8中抽象类和接口的区别</p>
<blockquote>
<p><strong>Java 抽象类</strong></p>
<p>在面向对象的概念中，所有的对象都是通过类来描绘的，但是反过来，并不是所有的类都是用来描绘对象的，<strong>如果一个类中没有包含足够的信息来描绘一个具体的对象，这样的类就是抽象类。</strong><br>        抽象类除了不能实例化对象之外，类的其它功能依然存在，成员变量、成员方法和构造方法的访问方式和普通类一样。<br>        <strong>由于抽象类不能实例化对象，所以抽象类必须被继承，才能被使用。</strong>也是因为这个原因，通常在设计阶段决定要不要设计抽象类。只有抽象类的非抽象子类可以创建对象。<br>父类包含了子类集合的常见的方法，但是由于父类本身是抽象的，所以不能使用这些方法。</p>
<p>在Java中抽象类表示的是一种继承关系，一个类只能继承一个抽象类，而一个类却可以实现多个接口。<br>使用abstract class来定义抽象类<br><strong>抽象方法</strong><br>如果你想设计这样一个类，该类包含一个特别的成员方法，该方法的具体实现由它的子类确定，那么你可以在父类中声明该方法为抽象方法。（只声明，不含方法体，就是不给出方法的具体实现也就是方法的具体功能）</p>
<ul>
<li>如果一个类包含抽象方法，那么该类必须是抽象类。</li>
<li>任何子类必须重写父类的抽象方法，或者声明自身为抽象类。否则，从最初的父类到最终的子类都不能用来实例化对象。</li>
<li>构造方法，类方法（用 static 修饰的方法）不能声明为抽象方法。</li>
</ul>
<hr>
<p><strong>Java接口</strong></p>
<p>接口（英文：Interface），在JAVA编程语言中是<strong>一个抽象类型</strong>，<strong>是抽象方法的集合</strong>，接口通常<strong>以interface来声明</strong>。一个类通过继承接口的方式，从而来继承接口的抽象方法。</p>
<p>接口并不是类，编写接口的方式和类很相似，但是它们属于不同的概念。<strong>类描述对象的属性和方法。接口则包含类要实现的方法。</strong></p>
<p>除非实现接口的类是抽象类，否则该类要定义接口中的所有方法。</p>
<p>接口无法被实例化，但是可以被实现。接口中的方法是不能在接口中实现的，<strong>只能由实现接口的类来实现接口中的方法。</strong>一个实现接口的类，必须实现接口内所描述的所有方法，否则就必须声明为抽象类。<strong>另外</strong>，在 Java 中，接口类型可用来声明一个变量，他们可以成为一个空指针，或是被绑定在一个以此接口实现的对象。</p>
<h3 id="接口与类相似点："><a href="#接口与类相似点：" class="headerlink" title="接口与类相似点："></a>接口与类相似点：</h3><ul>
<li>一个接口可以有多个方法。</li>
<li>接口文件保存在 .java 结尾的文件中，文件名使用接口名，字节码文件保存在 .class 结尾的文件中，且相应的字节码文件必须在与包名称相匹配的目录结构中。</li>
</ul>
<h3 id="接口与类的区别："><a href="#接口与类的区别：" class="headerlink" title="接口与类的区别："></a>接口与类的区别：</h3><ul>
<li>接口不能用于实例化对象，也没有构造方法。</li>
<li>接口中所有的方法必须是抽象方法。</li>
<li>接口不能包含成员变量，除了 static 和 final 变量。</li>
<li>接口不是被类继承了，而是要被类实现。</li>
<li>接口支持多继承。</li>
</ul>
<h3 id="抽象类和接口的区别"><a href="#抽象类和接口的区别" class="headerlink" title="抽象类和接口的区别"></a>抽象类和接口的区别</h3><ul>
<li>抽象类中的方法可以有方法体(就是能实现方法的具体功能)，但是接口中的方法不行。</li>
<li>抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是 <strong>public static final</strong> 类型的。</li>
<li>接口中不能含有静态代码块以及静态方法(用 static 修饰的方法)(<em>JDK 1.8 以后，接口里可以有静态方法和方法体了。</em>)，而抽象类是可以有静态代码块和静态方法。</li>
<li>一个类只能继承一个抽象类，而一个类却可以实现多个接口。</li>
</ul>
<p>重写接口中<strong>实现</strong>的方法时，需要注意以下<strong>规则：</strong></p>
<ul>
<li><p>类在实现接口的方法时，不能抛出强制性异常，只能在接口中，或者继承接口的抽象类中抛出该强制性异常。</p>
</li>
<li><p>类在重写方法时要保持一致的方法名，并且应该保持相同或者相兼容的返回值类型。</p>
</li>
<li><p>如果实现接口的类是抽象类，那么就没必要实现该接口的方法。</p>
</li>
<li><p>一个类可以同时实现多个接口。</p>
</li>
<li><p>一个类只能继承一个类，但是能实现多个接口。</p>
</li>
<li><p>一个接口能继承另一个接口，这和类之间的继承比较相似。</p>
</li>
</ul>
<p><strong>标记接口</strong></p>
<p>标记接口是没有任何方法和属性的接口。它仅仅表明它的类属于一个特定的类型,供其他代码来测试允许做一些事情<br>   <strong>作用</strong>：简单形象的说就是给某个对象打个标（盖个戳），使对象拥有某个或某些特权。</p>
<p>主要用于以下两种<strong>目的</strong>：<br>        建立一个公共的父接口：<br>  正如EventListener接口，这是由几十个其他接口扩展的Java API，你可以使用一个标记接口来建立一组接口的父接口。例如：当一个接口继承了EventListener接口，Java虚拟机(JVM)就知道该接口将要被用于一个事件的代理方案。<br>        向一个类添加数据类型：<br>  这种情况是标记接口最初的目的，实现标记接口的类不需要定义任何接口方法(因为标记接口根本就没有方法)，但是该类通过多态性变成一个接口类型。</p>
</blockquote>
<p><strong>8.什么是值传递和引用传递？</strong><br><strong>值传递：</strong>在方法被调用时，实参通过形参把<strong>它的内容副本传入方法内部</strong>，此时形参接收到的内容是实参值的一个拷贝，因此在方法内对形参的任何操作，都仅仅是对这个副本的操作，不影响原始值的内容。</p>
<p><strong>引用传递：</strong>”引用”也就是指向真实内容的地址值，在方法调用时，<strong>实参的地址通过方法调用被传递给相应的形参</strong>，在方法体内，形参和实参指向通愉快内存地址，对形参的操作会影响的真实内容。对象被引用传递，意味着传递的并不是实际的对象，而是对象的引用。因此，外部对引用对象所做的改变会反映到所有的对象上。</p>
<p>因此可见：在Java中所有的参数传递，不管基本类型还是引用类型，都是值传递，或者说是副本传递。<br>只是在传递过程中：如果是对基本数据类型的数据进行操作，由于原始内容和副本都是存储实际值，并且是在不同的栈区，因此形参的操作，不影响原始内容。如果是对引用类型的数据进行操作，分两种情况，一种是形参和实参保持指向同一个对象地址，则形参的操作，会影响实参指向的对象的内容。一种是形参被改动指向新的对象地址（如重新赋值引用），则形参的操作，不会影响实参指向的对象的内容。</p>
<p><strong>9.创建线程有几种不同的方式？你喜欢哪一种？为什么？</strong><br>有三种方式可以用来创建线程：<br>• 继承Thread类<br>• 实现Runnable接口<br>• 应用程序可以使用Executor框架来创建线程池<br>实现Runnable接口这种方式更受欢迎，因为这不需要继承Thread类。在应用设计中已经继承了别的对象的情况下，这需要多继承（而Java不支持多继承），只能实现接口。同时，线程池也是非常高效的，很容易实现和使用。</p>
<p><strong>10.同步方法和同步代码块的区别是什么？</strong><br>在Java语言中，每一个对象有一把锁。线程可以使用synchronized关键字来获取对象上的锁。synchronized关键字可应用在方法级别(粗粒度锁：这里的锁对象可以是This)或者是代码块级别(细粒度锁：这里的锁对象就是任意对象)。</p>
<p><strong>11.什么是死锁(deadlock)？</strong><br>两个进程都在等待对方执行完毕才能继续往下执行的时候就发生了死锁。结果就是两个进程都陷入了无限的等待中。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/03/08/Java%E5%9F%BA%E7%A1%80%E5%B8%B8%E8%A7%81%E7%AC%94%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/" data-id="ck7j608000000mov9ceipa2s3" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2020/02/08/article-title/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">article title</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">March 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/02/">February 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/03/08/Java%E5%9F%BA%E7%A1%80%E5%B8%B8%E8%A7%81%E7%AC%94%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/">Java基础常见笔试题总结</a>
          </li>
        
          <li>
            <a href="/2020/02/08/article-title/">article title</a>
          </li>
        
          <li>
            <a href="/2020/02/07/hello-world/">Hello World</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>